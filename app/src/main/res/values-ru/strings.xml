<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="action_settings">Настройки</string>

    <string name="menu_theory">Теория</string>
    <string name="menu_crypto">Криптография</string>
    <string name="menu_feedback">Обратная связь</string>
    <string name="menu_qr_scanner">QR сканнер</string>
    <string name="menu_settings">Настройки</string>
    <string name="menu_manual">Гид</string>
    <string name="menu_about">О приложении</string>

    <string name="crypto_titleEncrypt">Зашифровать</string>
    <string name="crypto_titleDecrypt">Расшифровать</string>
    <string name="crypto_titleMethod">Метод</string>
    <string name="crypto_titleKey">Ключ</string>
    <string name="crypto_titleEncryptText">Зашифрованный текст</string>
    <string name="crypto_titleDecryptText">Расшифрованный текст</string>
    <string name="crypto_titleClear">Очистить</string>
    <string name="clearForm">Форма очищена</string>
    <string name="crypto_helpEnterKey">Введите ключ для криптографии</string>
    <string name="crypto_helpEnterOpenText">Введите открытый текст</string>
    <string name="crypto_helpEnterCloseText">Введите закрытый текст</string>
    <string name="crypto_helpEnterText">Введите текст</string>
    <string name="incorrectKey">Неправильно введен ключ</string>
    <string name="error_enterQR">Введите текст для отображения QR-кода</string>


    <string name="qrScanner_scan">Сканировать</string>
    <string name="qrScanner_create">Создать</string>

    <string name="toast_savedImage">Изображение успешно сохранено</string>
    <string name="toast_notSavedImage">Изображение не сохранено</string>

    <string name="about_titleFeedback">Отправить отзыв</string>
    <string name="about_hintFeedback">Помогите нам сделать приложение лучше</string>
    <string name="about_opedDM">Открыт режим разработчика</string>
    <string name="about_closeDM">Закрыт режим разработчика</string>

    <string name="settings_titleGeneral">Общие</string>
    <string name="settings_titleOptional">Дополнительные</string>
    <string name="settings_uploaded">Данные подгружены</string>
    <string name="settings_enterLog">Получены логи</string>
    <string name="settings_camera">Камера</string>
    <string name="settings_intMemory">Внутренняя память</string>
    <string name="settings_connectMC">Подключить МК</string>
    <string name="settings_titlePermManag">Управление разрешениями</string>
    <string name="setting_titleDev">Для разработчика</string>
    <string name="setLocaleChan">Изменена локализация приложения</string>


    <string name="copyBuf">Данные скопированы в буфер обмена</string>
    <string name="about_app_version">Версия приложения</string>

    <string name="settings_spinner_lang_En">Английский</string>
    <string name="settings_spinner_lang_Ru">Русский</string>
    <string name="settings_spinner_systemic">Системный</string>
    <string name="tempUnav">Функция временно недоступна</string>

    <string name="theory_AES_head">
        AES — это симметричный блочный шифр, принятый в качестве стандарта шифрования правительством США в результате конкуренции с AES.
        Этот алгоритм был хорошо проанализирован и в настоящее время широко используется, как и его предшественник DES.
        Национальный институт стандартов и технологий США опубликовал спецификацию AES 26 ноября 2001 г. после пятилетнего перерыва.
        период, в течение которого были созданы и оценены 15 кандидатов. 26 мая 2002 года AES был объявлен стандартом шифрования.
        По состоянию на 2009 год AES является одним из наиболее широко используемых алгоритмов симметричного шифрования. Intel представила поддержку ускорения AES
        к семейству процессоров x86, начиная с Arrandale в 2010 году и позже процессоров Sandy Bridge; AMD работает с Bulldozer с 2011 года.
    </string>
    <string name="theory_AES_history">
        2 января 1997 г. NIST объявляет о своем намерении выбрать преемника стандарта DES, который является американским стандартом с 1977 г. 2 октября 2000 г.
        было объявлено, что победителем конкурса стал алгоритм Rijndael, и началась процедура стандартизации. 28 февраля 2001 г. проект
        был опубликован, и 26 ноября 2001 г. AES был принят как FIPS 197. Историческую ретроспективу конкурса можно найти на веб-сайте NIST.
    </string>
    <string name="theory_AES_encryption">
        AES — это стандарт, основанный на алгоритме Rijndael. Для AES длина input и State постоянна и равна 128 бит, а длина ключа шифрования K равна 128,
        192 или 256 бит. При этом оригинальный алгоритм Rijndael допускает длину ключа и размер блока от 128 до 256 бит с шагом 32 бита. Для обозначения
        выбранные длины ввода, состояния и ключа шифра в 32-битных словах, для разных длин ключей используется обозначение Nb = 4 для ввода и состояния, Nk = 4, 6, 8 для ключа шифра соответственно.
        В начале шифрования ввод копируется в массив State по правилу state[r,c]=input[r+4c]. После этого к состоянию применяется процедура AddRoundKey(),
        и далее State проходит процедуру преобразования (раунд) 10, 12 или 14 раз (в зависимости от длины ключа), при этом учитывая, что последний раунд немного отличается от
        предыдущие. В результате после завершения последнего раунда преобразования State копируется на выход по правилу output[r+4c]=state[r,c].
        Отдельные преобразования SubBytes(), ShiftRows(), MixColumns() и AddRoundKey() обрабатывают состояние. Массив w[] - содержит расписание ключей.
    </string>
    <string name="theory_AES_cryptographic_strength">
        В июне 2003 года Агентство национальной безопасности США определило, что шифр AES достаточно надежен, чтобы его можно было использовать для защиты государственных секретов. До уровня SECRET разрешалось использовать 128-битные ключи;
        для уровня «СОВЕРШЕННО СЕКРЕТНО» требовались 192- и 256-битные ключи.
    </string>

    <string name="theory_DES_head">
        DES (Стандарт шифрования данных) — это алгоритм симметричного шифрования, разработанный IBM и одобренный правительством США в 1977 году в качестве официального стандарта (FIPS 46-3). Размер блока для DES составляет 64 бита.
        Алгоритм основан на сети Фейстеля с 16 циклами (раундами) и 56-битным ключом. Алгоритм использует комбинацию нелинейных (S-блоки) и линейных (перестановки E, IP, IP-1) преобразований.
        В настоящее время прямым развитием DES является алгоритм Triple DES (3DES). В 3DES шифрование/дешифрование выполняется путем трехкратного запуска алгоритма DES.
    </string>
    <string name="theory_DES_history">
        В 1972 году было проведено исследование потребности правительства США в компьютерной безопасности. Американское «Национальное бюро стандартов» (NBS) (теперь известное как NIST — «Национальный институт стандартов и технологий»)
        выявила необходимость общегосударственного стандарта шифрования некритической информации.
        NBS проконсультировалась с АНБ (Агентством национальной безопасности США) и 15 мая 1973 года объявила первый конкурс на создание шифра. Были сформулированы жесткие требования к новому шифру.
        IBM вступила в соревнование с разработанным ею шифром под названием «Люцифер». Шифры ни одного из конкурсантов (в том числе «Люцифера») не обеспечили выполнение всех требований. В 1973-1974 гг.
        IBM доработала своего «Люцифера»: в его основе был созданный ранее алгоритм Хорста Фейстеля. 27 августа 1974 года начались вторые соревнования. На этот раз приемлемым сочли шифр «Люцифер».
        17 марта 1975 года предложенный алгоритм DES был опубликован в Федеральном реестре. В 1976 году было проведено два открытых симпозиума для обсуждения DES. На симпозиумах сильно обсуждались изменения, внесенные в алгоритм АНБ.
        критиковал. АНБ уменьшило исходную длину ключа и S-блоки (замещающие блоки), критерии проектирования которых не разглашаются. АНБ подозревали в преднамеренном ослаблении алгоритма, чтобы АНБ могло легко просматривать зашифрованные сообщения.
    </string>
    <string name="theory_DES_cryptographic_strength">
        В 1990 году Эли Бихам и Ади Шамир провели независимое исследование дифференциального криптоанализа, основного метода взлома алгоритмов блочного симметричного шифрования. Эти исследования сняли некоторые подозрения о скрытой слабости S-перестановок.
        S-блоки алгоритма DES оказались гораздо более устойчивыми к атакам, чем если бы они были выбраны случайным образом. Это означает, что этот метод анализа был известен АНБ еще в 1970-х годах. Алгоритм DES был «взломан» за 39 дней с использованием огромной сети из десятков тысяч компьютеров.
        Общественная организация «EFF», занимающаяся проблемами информационной безопасности и неприкосновенности частной жизни в сети Интернет, инициировала исследование «DES Challenge II» с целью выявления проблем с DES. В рамках исследования сотрудники лаборатории RSA построили суперкомпьютер стоимостью 250 000 долларов. В 1998 году суперкомпьютер
        расшифровал данные, закодированные по DES, с помощью 56-битного ключа менее чем за три дня. Суперкомпьютер получил название «EFF DES Cracker». Специально по этому поводу ученые организовали пресс-конференцию и с опаской высказались о том, что злоумышленники вряд ли упустят возможность воспользоваться такой уязвимостью.
        Некоторые правительственные чиновники и эксперты утверждают, что для взлома кода DES требуется многомиллионный суперкомпьютер. «Правительству пора признать небезопасность DES и поддержать создание более надежного стандарта шифрования», — сказал президент EFF Барри Стейнхардт. Экспортные ограничения
        введенные правительством США, применяются к технологиям шифрования с ключами длиннее 40 бит. Однако, как показали результаты эксперимента Лаборатории RSA, существует возможность взлома еще более мощного кода.
    </string>

    <string name="theory_RC4_head">
        RC4 (от англ. Rivest cipher 4 или Ron’s code), также известен как ARC4 или ARCFOUR (alleged RC4) — потоковый шифр, широко применяющийся в различных системах защиты информации в компьютерных сетях (например, в протоколах SSL и TLS, алгоритмах обеспечения безопасности беспроводных сетей WEP и WPA). Шифр разработан компанией RSA Security,
        и для его использования требуется лицензия. Алгоритм RC4, как и любой потоковый шифр, строится на основе генератора псевдослучайных битов. На вход генератора записывается ключ, а на выходе читаются псевдослучайные биты. Длина ключа может составлять от 40 до 2048 бит[1]. Генерируемые биты имеют равномерное распределение.
        Основные преимущества шифра: высокая скорость работы; переменный размер ключа. RC4 довольно уязвим, если: используются не случайные или связанные ключи; один ключевой поток используется дважды.
    </string>
    <string name="theory_RC4_history">
        Потоковый шифр RC4 был создан Рональдом Ривестом, сотрудником компании RSA Security, в 1987 году. Сокращение «RC4» официально обозначает «Rivest cipher 4» или «шифр Ривеста» («4» — номер версии; RC1 никогда не публиковался; RC3 разрабатывался, но в нём была найдена уязвимость), но его часто считают сокращением от «Ron’s code» («код Рона»).
        В течение семи лет шифр являлся коммерческой тайной, и точное описание алгоритма предоставлялось только после подписания соглашения о неразглашении, но в сентябре 1994 года его описание было анонимно отправлено в список рассылки (англ. mailing list) «Cypherpunks». Вскоре описание RC4 было опубликовано в группе новостей usenet «sci.crypt».
        Оттуда исходный код попал на множество сайтов в сети Интернет. Опубликованный алгоритм на выходе выдавал шифротексты, совпадающие с шифротекстами, выдаваемыми подлинным RC4. Обладатели легальных копий исходного кода RC4 подтвердили идентичность алгоритмов при различиях в обозначениях и структуре программы. Поскольку данный алгоритм известен,
        он более не является коммерческой тайной. Однако, название «RC4» является торговой маркой компании RSA Security. Чтобы избежать возможных претензий со стороны владельца торговой марки, шифр иногда называют «ARCFOUR» или «ARC4», имея в виду англ. alleged RC4 — «предполагаемый» RC4 (поскольку «RSA Security» официально не опубликовала алгоритм).
    </string>
    <string name="theory_RC4_security">
        В отличие от современных шифров (таких, как eSTREAM), RC4 не использует nonce (от англ. nonce — «number that can only be used once» — число, которое может быть использовано один раз) наряду с ключом. Это значит, что если один ключ должен использоваться в течение долгого времени для шифрования нескольких потоков, сама криптосистема, использующая RC4,
        должна комбинировать оказию и долгосрочный ключ для получения потокового ключа для RC4. Один из возможных выходов — генерировать новый ключ для RC4 с помощью хеш-функции от долгосрочного ключа и nonce. Однако многие приложения, использующие RC4, просто конкатенируют ключ и nonce. Из-за этого и слабого расписания ключей, используемого в RC4, приложение
        может стать уязвимым. Поэтому он был признан устаревшим многими софтверными компаниями, такими как Microsoft.
    </string>
    <string name="theory_RC4_cryptographic_strength_1">
        В 2001 году Флурер, Мантин и Шамир опубликовали работу об уязвимости ключевого расписания RC4. Они показали, что первые байты ключевого потока среди всех возможных ключей неслучайны. Из этих байтов можно с высокой вероятностью получить информацию об используемом шифром ключе. И если долговременный ключ и nonce просто склеиваются для создания ключа шифра RC4,
        то этот долговременный ключ может быть получен с помощью анализа достаточно большого количества сообщений, зашифрованных с использованием данного ключа. Эта уязвимость и некоторые связанные с ней эффекты были использованы при взломе шифрования WEP в беспроводных сетях стандарта IEEE 802.11. Это показало необходимость скорейшей замены WEP, что повлекло за собой
        разработку нового стандарта безопасности беспроводных сетей WPA.
    </string>
    <string name="theory_RC4_cryptographic_strength_2">
        В 2005 году Андреас Кляйн представил анализ шифра RC4, в котором он указал на сильную коррелированность ключа и ключевого потока RC4. Кляйн проанализировал атаки на первом раунде (подобные атаке ФМШ), на втором раунде и возможные их улучшения. Он также предложил некоторые изменения алгоритма для усиления стойкости шифра. В частности, он утверждает, что если поменять
        направление цикла на обратное в алгоритме ключевого расписания, то можно сделать шифр более стойким к атакам типа ФМШ.
    </string>

    <string name="theory_RSA_head">
        RSA (аббревиатура от фамилий Rivest, Shamir и Adleman) — криптографический алгоритм с открытым ключом, основывающийся на вычислительной сложности задачи факторизации больших простых чисел. Криптосистема RSA стала первой системой, пригодной и для шифрования, и для цифровой подписи. Алгоритм используется в большом числе криптографических приложений, включая PGP, S/MIME,
        TLS/SSL, IPSEC/IKE и других.
    </string>
    <string name="theory_RSA_history">
        Идея асимметричной криптосистемы с открытым и закрытым ключом приписывается Уитфилду Диффи и Мартину Хеллману, которые опубликовали эту концепцию в 1976 году. Они также ввели цифровые подписи и попытались применить теорию чисел. В их формулировке использовался секретный ключ с общим доступом, созданный путем экспоненциализации некоторого числа по модулю простого числа.
        Однако они оставили открытой проблему реализации односторонней функции, возможно, потому что сложность факторизации в то время не была хорошо изучена. Рон Ривест, Ади Шамир и Леонард Адлеман из Массачусетского технологического института в течение года предприняли несколько попыток создать одностороннюю функцию, которую было бы трудно инвертировать. Ривест и Шамир, будучи
        компьютерными учеными, предложили множество потенциальных функций, а Адлеман, будучи математиком, отвечал за поиск их слабых мест. Они опробовали множество подходов, включая "ранцевый" и "перестановочные полиномы". Какое-то время они думали, что то, чего они хотели достичь, невозможно из-за противоречивых требований. В апреле 1977 года они провели Песах в доме одного из
        студентов и выпили много манишевицкого вина, а затем вернулись к себе домой около полуночи. Ривест, не в силах заснуть, лег на диван с учебником математики и начал думать о своей односторонней функции. Остаток ночи он провел, формализуя свою идею, и к рассвету большая часть статьи была готова. Алгоритм теперь известен как RSA - инициалы их фамилий в том же порядке, что и в их статье.
        Клиффорд Кокс, английский математик, работавший в британской разведывательной службе Government Communications Headquarters (GCHQ), описал эквивалентную систему во внутреннем документе в 1973 г. Однако, учитывая относительно дорогие компьютеры, необходимые для ее реализации в то время, она считалась в основном курьезом и, насколько известно, так и не была применена. Однако его открытие было
        раскрыто только в 1997 году из-за его сверхсекретного засекречивания.
    </string>

    <string name="theory_RSA_cryptographic_strength">
        Криптостойкость алгоритма RSA основывается на предположении, что исключительно трудно определить секретный ключ по известному, поскольку для этого необходимо решить задачу о существовании делителей целого числа. Данная задача является NP - полной. Известные точные алгоритмы для решения данной задачи имеют экспоненциальную оценку вычислительной сложности, следствием чего является невозможность получения
        точных решений для задач большой и даже средней размерности. Более того, сам вопрос существования эффективных алгоритмов решения NP - полных задач является до настоящего времени открытым. В связи с этим для чисел, состоящих из 200 цифр (а именно такие числа рекомендуется использовать), традиционные методы требуют выполнения огромного числа операций(около 1023). Все асимметричные криптосистемы пытаются
        взломать путем прямого перебора ключей. Поэтому в асимметричных криптосистемах используют длинные ключи. Для обеспечения эквивалентного уровня защиты ключ асимметричной криптосистемы должен быть гораздо длиннее ключа симметричной криптосистемы. Это сразу же сказывается на вычислительных ресурсах, требуемых для шифрования. Брюс Шнейер в книге "Прикладная криптография: протоколы, алгоритмы и исходный текст
        на C" приводит следующие данные об эквивалентных длинах ключей.
        Для того чтобы избежать низкой скорости алгоритмов асимметричного шифрования, генерируется временный симметричный ключ для каждого сообщения и только он шифруется асимметричными алгоритмами. Само сообщение шифруется с использованием этого временного сеансового ключа. Затем этот сеансовый ключ шифруется с помощью открытого асимметричного ключа получателя и асимметричного алгоритма шифрования. После этого
        этот зашифрованный сеансовый ключ вместе с зашифрованным сообщением передается получателю. Получатель использует тот же самый асимметричный алгоритм шифрования и свой секретный ключ для расшифровки сеансового ключа, а полученный сеансовый ключ используется для расшифровки самого сообщения. В асимметричных криптосистемах важно, чтобы сеансовые и асимметричные ключи были сопоставимы в отношении уровня
        безопасности, который они обеспечивают. Если используется короткий сеансовый ключ (например, DES), то не имеет значения, насколько велики асимметричные ключи. Хакеры будут атаковать не их, а сеансовые ключи. Асимметричные открытые ключи уязвимы к атакам прямым перебором отчасти из-за того, что их тяжело заменить. Если атакующий узнает секретный асимметричный ключ, то будет скомпрометирован не только
        текущее, но и все последующие взаимодействия между отправителем и получателем.
    </string>

    <string name="theory_3DES_head">
        Triple DES (3DES) — симметричный блочный шифр, созданный Уитфилдом Диффи, Мартином Хеллманом и Уолтом Тачманном в 1978 году на основе алгоритма DES с целью устранения главного недостатка последнего — малой длины ключа (56 бит), который может быть взломан методом полного перебора ключа. Скорость работы 3DES в 3 раза ниже, чем у DES, но криптостойкость намного выше — время, требуемое для криптоанализа 3DES,
        может быть в миллиард раз больше, чем время, нужное для вскрытия DES. 3DES используется чаще, чем DES, который легко взламывается при помощи сегодняшних технологий (в 1998 году организация Electronic Frontier Foundation, используя специальный компьютер DES Cracker, вскрыла DES за 3 дня). 3DES является простым способом устранения недостатков DES. Алгоритм 3DES построен на основе DES, поэтому для его
        реализации возможно использовать программы, созданные для DES. Официальное название алгоритма, используемое в стандартах - TDEA или Triple DEA (англ. Triple Data Encryption Algorithm). Однако, термин "3DES" используется более широко поставщиками, пользователями и разработчиками криптосистем.
    </string>

    <string name="theory_Atbash_head">
        Атбаш (ивр. ‏אתבש‏‎) — простой шифр подстановки для алфавитного письма. Правило шифрования состоит в замене i буквы алфавита буквой с номером n-i+1, где n — число букв в алфавите. Впервые встречается в древнееврейском тексте Библии / Танаха.Шифр Атбаш можно также рассматривать как частный случай аффинного шифра. Происхождение слова «атбаш» объясняется принципом замены букв. Слово (точнее - аббревиатура
        на древнееврейском языке) "אתבש" составлено из букв «алеф», «тав», «бет» и «шин», то есть первой, последней, второй и предпоследней букв еврейского алфавита. В Иер 51:1 слова לב קמי «лев камай» (букв. «сердце моих противников») являются «атбашем» слова כשדים «касдим» («халдеи»), а в Иер. 25:26, 51:41 слово ששך («шешах», или «сесах» в синодальном переводе) — это атбаш слова בבל «Бавель».
    </string>
    <string name="theory_Atbash_history">
        Шифр Атбаш встречается уже в упомянутых местах Библии / Танаха и таким образом, можно сделать вывод, что он был уже известен во времена создания Танаха. Согласно другим (менее достоверным сведениям) он был, скорее всего, изобретен Ессеями, иудейской сектой повстанцев. Они разработали множество различных кодов и шифров, которые использовались для сокрытия важных имен и названий, чтобы потом избежать преследования.
        Знания этих кодов и шифров были потом, согласно легендарным сведениям, переданы Гностикам, которые, в свою очередь, передали их Катарам. Позже Орден Тамплиеров завербовал Катарских дворян и перенял знания шифров. Таким образом, шифр был использован на протяжении многих лет, от около 500 до н. э. до 1300 г. н. э. — момента, когда Орден Тамплиеров был распущен (точнее - перестал существовать на территории Франции,
        продолжил существование в Португалии, Шотландии и др. странах). Происхождение шифра Атбаш (и других шифров) в источниках иудаизма имеет совершенно другую историю.
    </string>

    <string name="theory_Vigener_head">
        Шифр Виженера (фр. Chiffre de Vigenere) — метод полиалфавитного шифрования буквенного текста с использованием ключевого слова. Этот метод является простой формой многоалфавитной замены. Шифр Виженера изобретался многократно. Впервые этот метод описал Джовани Баттиста Белласо (итал. Giovan Battista Bellaso) в книге La cifra del. Sig. Giovan Battista Bellasо в 1553 году, однако в XIX веке получил имя Блеза Виженера,
        французского дипломата. Метод прост для понимания и реализации, но является недоступным для простых методов криптоанализа. Хотя шифр легко понять и реализовать, на протяжении трех столетий он противостоял всем попыткам его сломать; чем и заработал имя le chiffre indéchiffrable (фр. неразгаданный шифр). Многие люди пытались реализовать схемы шифрования, которые по сути являлись шифрами Виженера.
    </string>
    <string name="theory_Vigener_history"><![CDATA[
        В 1466 году Леон Альберти, знаменитый архитектор и философ представил трактат о шифрах в папскую канцелярию. В трактате рассматриваются различные способы шифрования, в том числе маскировка открытого текста в некотором вспомогательном тексте. Работа завершается собственным шифром, который он назвал «шифр, достойный королей». Это был многоалфавитный шифр, реализованный в виде шифровального диска. Суть заключается в том,
        что в данном шифре используется несколько замен в соответствии с ключом. Позднее Альберти изобрел код с перешифровкой. Данное изобретение значительно опередило свое время, поскольку данный тип шифра стал применяться в странах Европы лишь 400 лет спустя. В 1518 году в развитии криптографии был сделан новый шаг благодаря появлению в Германии первой печатной книги по криптографии. Аббат Иоганн Тритемий, настоятель монастыря
        в Вюрцбурге, написал книгу «Полиграфия», в которой дается описание ряда шифров. Один из них использует «таблицу Тритемия» (ныне «таблицу Виженера») и развивает идею многоалфавитной замены. Система шифрования следующая: первая буква исходного текста шифруется по первой строке, вторая по второй и так далее. После использования последней строки следующая буква вновь шифруется по первой строке. В шифре Тритемия отсутствует ключ,
        секретом является сам способ шифрования.<br>
        Следующий шаг в развитии предложенного Тритемием способа шифрования был сделан итальянцем Джовани Белазо. В 1553 году выходит в свет его брошюра «Шифр синьора Белазо». В этом шифре ключом является так называемый пароль — фраза или слово. Пароль записывался периодически над буквами открытого текста. Буква пароля, стоящая над соответствующей буквой открытого текста, указывала номер строки в таблице Тритемия, по которой следует
        проводить замену (шифрование) это буквы.<br>
        В последующем идеи Тритемия и Белазо развил соотечественник Белазо Джованни Батиста Порта. Он предложил отказаться от алфавитного порядка следования букв в первой строке таблицы Тритемия и заменить этот порядок на некоторый произвольный, являющийся ключом шифра. Строки таблицы по-прежнему циклически сдвигались. В своей книге «О тайной переписке», Порта предложил биграммный шифр, а также привел описание механического дискового
        устройства, реализующего биграммную замену.<br>
        В середине XVI века в Италии появляется книга Дж. Кардано «О тонкостях» с дополнением «О разных вещах». Там нашли отражение новые идеи криптографии: использование части самого передаваемого открытого текста в качестве ключа шифра (идея «самоключа») и новый способ шифрования, который вошел в историю как «решетка Кардано». Посол Франции в Риме Блез де Виженер, познакомившись с трудами Тритемия, Белазо, Кардано, Порта, Альберти,
        также увлекся криптографией. В 1585 году он написал «Трактат о шифрах», в котором излагаются основы криптографии. В этом труде он замечает: «Все вещи в мире представляют собой шифр. Вся природа является просто шифром и секретным письмом». Эта мысль была позднее повторена Блезом Паскалем — одним из основоположников теории вероятностей, а в XX веке и Норбертом Винером — «отцом кибернетики». По сути дела Виженер объединил подходы
        Тритемия, Беллазо, Порта к шифрованию открытых текстов, по существу не внеся в них ничего оригинального. В наше время «шифр Виженера», состоящий в периодическом продолжении ключевого слова по таблице Тритемия, вытеснил имена его предшественников. Дэвид Кан в своей книге «Взломщики кодов» отозвался об этом осуждающе, написав, что история «проигнорировала важный факт и назвала шифр именем Виженера, несмотря на то, что он ничего не
        сделал для его создания»<br>
        Шифр Виженера имел репутацию исключительно стойкого к «ручному» взлому. Известный писатель и математик Чарльз Лютвидж Доджсон (Льюис Кэрролл) назвал шифр Виженера невзламываемым в своей статье «Алфавитный шифр» англ. The Alphabet Cipher, опубликованной в детском журнале в 1868 году. В 1917 году Scientific American также отозвался о шифре Виженера как о не поддающемся взлому. Это представление было опровергнуто после того, как Касиски
        полностью взломал шифр в XIX веке, хотя известны случаи взлома этого шифра некоторыми опытными криптоаналитиками ещё в XVI веке.
        Шифр Виженера достаточно прост для использования в полевых условиях, особенно если применяются шифровальные диски. Например, «конфедераты» использовали медный шифровальный диск для шифра Виженера в ходе Гражданской войны. Послания Конфедерации были далеки от секретных, и их противники регулярно взламывали сообщения. Во время войны командование Конфедерации полагалось на три ключевых словосочетания: «Manchester Bluff», «Complete Victory»
        и — так как война подходила к концу — «Come Retribution».<br>
        Гилберт Вернам попытался улучшить взломанный шифр (он получил название шифр Вернама-Виженера в 1918 году), но, несмотря на его усовершенствования, шифр так и остался уязвимым для криптоанализа. Однако работа Вернама в итоге всё же привела к получению шифра Вернама, который действительно невозможно взломать.
   ]]> </string>
    <string name="theory_Vigener_cryptoanalysis">
        Шифр Виженера «размывает» характеристики частотностей появления символов в тексте, но некоторые особенности появления символов в тексте остаются. Главный недостаток шифра Виженера состоит в том, что его ключ повторяется. Поэтому простой криптоанализ шифра может быть построен в два этапа:
        Поиск длины ключа. Можно анализировать распределение частотностей в зашифрованном тексте с различным прореживанием. То есть брать текст, включающий каждую 2-ю букву зашифрованного текста, потом каждую 3-ю и т. д. Как только распределение частотностей букв будет сильно отличаться от равномерного (например, по энтропии), то можно говорить о найденной длине ключа.
        Криптоанализ. Совокупность l шифров Цезаря (где l — найденная длина ключа), которые по отдельности легко взламываются.
        Тесты Фридмана и Касиски могут помочь определить длину ключа.
    </string>
    <string name="theory_Vigener_frequency_analysis">
        Как только длина ключа становится известной, зашифрованный текст можно записать во множество столбцов, каждый из которых соответствует одному символу ключа. Каждый столбец состоит из исходного текста, который зашифрован шифром Цезаря; ключ к шифру Цезаря является всего-навсего одним символом ключа для шифра Виженера, который используется в этом столбце. Используя методы, подобные методам взлома шифра Цезаря, можно расшифровать зашифрованный текст.
        Усовершенствование теста Касиски, известное как метод Кирхгофа, заключается в сравнении частотности появления символов в столбцах с частотностью появления символов в исходном тексте для нахождения ключевого символа для этого столбца. Когда все символы ключа известны, криптоаналитик может легко расшифровать шифрованный текст, получив исходный текст. Метод Кирхгофа не применим, когда таблица Виженера скремблирована, вместо использования обычной алфавитной
        последовательности, хотя тест Касиски и тесты совпадения всё ещё могут использоваться для определения длины ключа для этого случая.
    </string>

    <string name="theory_XOR_head">
        Гамми́рование — метод симметричного шифрования, заключающийся в последовательности, состоящей из случайных чисел, на открытый текст. Последовательность случайных чисел называется гамма-последовательностью и используется для зашифровывания и расшифровывания данных. Суммирование обычно выполняется в каком-либо конечном поле. Например, в поле Галуа GF(2) суммирование принимает вид операции «исключающее ИЛИ (XOR)».
        Шифры гаммирования (аддитивные шифры) являются самыми эффективными с точки зрения стойкости и скорости преобразований (процедур зашифрования и дешифрования). По стойкости данные шифры относятся к классу совершенных. Для зашифрования и дешифрования используются элементарные арифметические операции – открытое/зашифрованное сообщение и гамма, представленные в числовом виде, складываются друг с другом по модулю (mod). Напомним, что результатом сложения двух
        целых чисел по модулю является остаток от деления (например, 5+10 mod 4 = 15 mod 4 = 3).
        В литературе шифры этого класса часто называют потоковыми, хотя к потоковым относятся и другие разновидности шифров. В шифрах гаммирования может использоваться сложение по модулю N (общий случай) и по модулю 2 (частный случай, ориентированный на программно-аппаратную реализацию).
    </string>

    <string name="theory_Gost_28147_89_head">
        ГОСТ 28147-89 «Системы обработки информации. Защита криптографическая. Алгоритм криптографического преобразования» — устаревший государственный стандарт СССР (а позже межгосударственный стандарт СНГ), описывающий алгоритм симметричного блочного шифрования и режимы его работы. Является примером DES-подобных криптосистем, созданных по классической итерационной схеме Фейстеля.
    </string>
    <string name="theory_Gost_28147_89_history">
        История создания шифра и критерии разработчиков были впервые публично представлены в 2014 году руководителем группы разработчиков алгоритма Заботиным Иваном Александровичем на лекции, посвященной 25-летию принятия российского стандарта симметричного шифрования. Работы над алгоритмом, положенным впоследствии в основу стандарта, начались в рамках темы «Магма» (защита информации криптографическими методами в ЭВМ ряда Единой Системы) по поручению Научно-технического
        совета Восьмого главного управления КГБ СССР, в марте 1978 года после длительного предварительного изучения опубликованного в 1976 году стандарта DES. В действительности работы по созданию алгоритма (или группы алгоритмов), схожего с алгоритмом DES, начались уже в 1976 году.
        Изначально работы имели гриф «Совершенно секретно». Затем были понижены до грифа «Секретно». В 1983 году гриф алгоритма был понижен до пометки «Для служебного пользования». Именно с последней пометкой алгоритм был подготовлен для публикации в 1989 году. 9 марта 1987 года группа разработчиков-криптографов (заявитель — в/ч 43753) получила авторское свидетельство с приоритетом № 333297 на изобретение на устройство шифрования по алгоритму «Магма-2».
        ГОСТ 28147-89 — блочный шифр с 256-битным ключом и 32 циклами (называемыми раундами) преобразования, оперирующий 64-битными блоками. Основа алгоритма шифра — сеть Фейстеля.
        Выделяют четыре режима работы ГОСТ 28147-89: простой замены, гаммирование, гаммирование с обратной связью и режим выработки имитовставки.
    </string>
    <string name="theory_Gost_28147_89_cryptoanalysis">
        Считается, что ГОСТ устойчив к таким широко применяемым методам, как линейный и дифференциальный криптоанализ. Обратный порядок использования ключей в последних восьми раундах обеспечивает защиту от атак скольжения (slide attack) и отражения (reflection attack). Ростовцев А. Г., Маховенко Е. Б., Филиппов А. С., Чечулин А. А. в своей работе описали вид криптоанализа, который сводится к построению алгебраической целевой функции и нахождению её экстремума.
        Были выделены классы слабых ключей, в частности, показано, что разреженные ключи (со значительным преобладанием 0 или 1) являются слабыми. По мнению авторов, их метод в любом случае лучше, чем полный перебор, однако без численных оценок. В мае 2011 года известный криптоаналитик Николя Куртуа доказал существование атаки на данный шифр, имеющей сложность в 28 (256) раз меньше сложности прямого перебора ключей при условии наличия 264 пар «открытый текст/закрытый» текст.
        Данная атака не может быть осуществлена на практике ввиду слишком высокой вычислительной сложности. Более того, знание 264 пар «открытый текст/закрытый» текст, очевидно, позволяет читать зашифрованные тексты, даже не вычисляя ключа. В большинстве других работ также описываются атаки, применимые только при некоторых предположениях, таких как определённый вид ключей или таблиц замен, некоторая модификация исходного алгоритма, или же требующие всё ещё недостижимых объёмов
        памяти или вычислений. Вопрос о наличии применимых на практике атак без использования слабости отдельных ключей или таблиц замены остается открытым.
    </string>
    <string name="theory_Gost_28147_89_criticism"><![CDATA[
        Основные проблемы стандарта связаны с неполнотой стандарта в части генерации ключей и таблиц замен. Считается, что у стандарта существуют «слабые» ключи и таблицы замен, но в стандарте не описываются критерии выбора и отсева «слабых». В октябре 2010 года на заседании 1-го объединённого технического комитета Международной организации по стандартизации (ISO/IEC JTC 1/SC 27) ГОСТ был выдвинут на включение в международный стандарт блочного шифрования ISO/IEC 18033-3.
        В связи с этим в январе 2011 года были сформированы фиксированные наборы узлов замены и проанализированы их криптографические свойства. Однако ГОСТ не был принят в качестве стандарта, и соответствующие таблицы замен не были опубликованы. Таким образом, существующий стандарт не специфицирует алгоритм генерации таблицы замен (S-блоков). С одной стороны, это может являться дополнительной секретной информацией (помимо ключа), а с другой, поднимает ряд проблем:
       <ui>
           <li> нельзя определить криптостойкость алгоритма, не зная заранее таблицы замен;</li>
           <li> реаизации алгоритма от различных производителей могут использовать разные таблицы замен и могут быть несовместимы между собой;</li>
           <li> возможность преднамеренного предоставления слабых таблиц замен лицензирующими органами РФ;</li>
           <li> потенциальная возможность (отсутствие запрета в стандарте) использования таблиц замены, в которых узлы не являются перестановками, что может привести к чрезвычайному снижению стойкости шифра.</li>
       </ui>
   ]]> </string>

    <string name="theory_Polybius_head">
        В криптографии квадрат Полибия (англ. Polybius square), также известный как шахматная доска Полибия — оригинальный код простой замены, одна из древнейших систем кодирования, предложенная Полибием. Данный вид кодирования изначально применялся для греческого алфавита, но затем был распространен на другие языки.
        Одну из первых систем шифрования, в которой использовалась таблица, описал древнегреческий историк Полибий. Точно неизвестно, является ли талантливый писатель автором этого шифра. Тем не менее специалисты называют этот шифр «квадратом Полибия». Еще до наступления нашей эры этот шифр широко применялся как греками, так и римлянами.
        При использовании данного шифра составляется таблица, которая, например, для английского алфавита состоит из пяти столбцов по пять строк в каждом. В каждую клетку этой таблицы в произвольном порядке вписывается одна из букв алфавита. Необходимо отметить, что для русского алфавита, содержащего большее количество букв, шифровальная таблица должна содержать не менее 30 клеток. Это может быть, например, таблица из шести столбцов по пять строк в каждом.
        Алгоритм шифрования заключается в том, что при преобразовании открытого текста в криптограмму необходимо найти в таблице ячейку с нужной буквой и вставить в шифрованный текст букву, располагающуюся в нижней от нее ячейке в том же столбце. Если же буква открытого текста оказывается в ячейке нижней строки, то в шифрограмму следует записать букву из верхней ячейки того же столбца.
    </string>
    <string name="theory_Morse_head">
        Азбука Морзе, «Морзянка», Код Мо́рзе — способ знакового кодирования, в котором буквы алфавита, цифры, знаки препинания и другие символы представляются в виде последовательностей коротких и длинных сигналов, называемых точками и тире. Предназначена для передачи по последовательным каналам связи. Уникальной особенностью азбуки Морзе является возможность кодирования и декодирования человеком без применения специальных терминальных устройств.
        Наиболее широко используется слуховой прием азбуки Морзе, который получил распространение в радиосвязи (слуховой радиотелеграф). В ВМФ код Морзе применяется в световой связи между кораблями, осуществляемой при помощи специальных сигнальных прожекторов. Тактильная передача кода Морзе встречается редко, в частности, она есть в некоторых моделях смарт-часов.
        В стандартном коде Морзе за единицу времени принимается длительность самого короткого сигнала — точки. Длительность тире равна трём точкам. Пауза между элементами одного знака — одна точка, между знаками в слове — 3 точки, между словами — 7 точек. Код может передаваться с любой доступной скоростью, причем возможность декодирования сохраняется и при значительных неточностях в соблюдении временных интервалов.
        Назван в честь американского изобретателя и художника Сэмюэля Морзе. Буквенные коды (собственно «азбука») были добавлены коллегой Морзе, Альфредом Вейлем — факт, который Морзе впоследствии всячески отрицал. Вейлемом же, возможно, была придумана и цифровая часть кода. А в 1848 году код Вейля/Морзе был усовершенствован немцем Фридрихом Герке. Код, усовершенствованный Герке, используется до настоящего времени.
    </string>
    <string name="theory_Morse_history_1">
        Азбука Морзе была создана изобретателями Сэмюэлем Морзе, Альфредом Вейлем и Джозефом Генри в 1838 году для изобретенного ими телеграфного аппарата, получившего название аппарат Морзе. Некоторые исследователи полагают, что автором кода был Альфред Вейл — партнёр Самюэля Морзе по бизнесу, известный тем, что ввел «коммерческий код» из групп по 5 символов.
        В отличие от первых телеграфных аппаратов стрелочного типа с довольно ненадежной передачей информации, которая часто производилась посредством сложных для того времени, многопроводных линий связи и с небольшими скоростями (порядка 25 слов в час), аппарат Морзе позволил в 10 раз повысить скорость передачи, применяя при этом только один сигнальный провод (вторым могла служить земля) и ведя автоматическое документирование в виде записи сигнала
        на бумажную ленту. Аппарат состоял из телеграфного ключа, которым телеграфист вручную модулировал ток в линии и приемного пишущего устройства, протягивающего перед иглой или валиком с краской бумажную ленту. Под действием электромагнита, подключенного к линии, валик прижимался к бумаге, оставляя на ней следы разной длительности, которыми, посредством азбуки Морзе, кодировалось переданное сообщение.
    </string>
    <string name="theory_Morse_history_2">
        Первый, оригинальный, код Морзе отличался от современного, в нем использовались посылки множества разных длительностей, «точка», «тире», «длинное тире» (в 4 раза длиннее «точки»), а так же паузы разной длины внутри символа. К примеру буква «C» (кириллический аналог - «Ц») кодировалась тремя точками в которых пауза между 1-й и 2-й была короткой а между 2-й и 3-й более длинной, а цифра «0» вообще представляла собой очень длинное тире (более 10 точек).
        Еще одним недостатком было то что не предусматривалась передача букв отсутствующих в английском алфавите, это осложняло использование кода в разных странах. В 1848 году Фридрих Герке усовершенствовал код Морзе, введя туда новые символы, сделав неизменными межэлементные паузы внутри символа и оставив только два по длительности элемента: короткий - точка и длительный - тире. С 1851 года код Герке, получивший название "гамбургский алфавит"
        или континентальный код Морзе, был принят в Германии и Австрии, первоначальный код Морзе при этом получил название американского.
        В 1865 году, на первой Международной телеграфной конференции, ставшей учредителем Международного союза электросвязи, разрабатывается и принимается международный вариант азбуки Морзе - International Morse code, который явился дальнейшим развитием кода Герке. Долгое время различные версии азбуки Морзе в разных странах сосуществовали независимо, это не вызывало больших неудобств так как телеграфные линии были проводными, однако в начале XX века
        началось бурное развитие радиосвязи и в 1930-х международный вариант азбуки Морзе вытеснил остальные. Он используется и в настоящее время.
        Русский вариант азбуки был принят в 1856 году. Для передачи русских букв использовались коды сходных латинских букв; это же соответствие алфавитов позже перешло в буквопечатающий телеграфный код МТК-2 (1963 г.), а потом в компьютерные кодировки кириллического алфавита КОИ-7 и КОИ-8. Отличием этих кодов стало изменение в интерпретации буквы «Q», которая в азбуке Морзе соответствует «Щ», а в МТК и КОИ — «Я».
        В 2004 году Международный союз электросвязи (МСЭ) ввёл в азбуку Морзе новый код для символа «коммерческое эт» @ (· — — · — ·) для удобства передачи адресов электронной почты.
        В настоящее время использование кода Морзе в электросвязи регламентировано Рекомендацией МСЭ-R M.1677-1 (10/2009). Согласно документу, официально определено 37 букв и цифр, а также 20 знаков препинания и других символов. В использовании знаков препинания и букв других языков, не имеющих аналогов в английском алфавите, до сих пор существуют некоторые разночтения в разных странах.
    </string>
    <string name="theory_Morse_coding_principle">
        Азбука Морзе является неравномерным кодом, основанным на принципе что более употребительные в английском языке буквы, кодируются более короткими и простыми сочетаниями точек и тире, что делает освоение азбуки Морзе проще, а передачу — быстрее. Этот принцип Самуэлем Морзе был подсмотрен в типографии, где он подсчитал количество типографских литер, используемых наборщиками в работе и тем самым, определил, какие буквы наиболее часто используются в текстах.
        Все буквы в азбуке содержат от 1 до 4 элементов, за исключением «Э», состоящей из пяти элементов (· · — · ·). Все цифры содержат по 5 элементов. Там как цифры являются довольно длинными, существует их сокращенный вариант, когда серия тире в символе заменяется одним тире, но при этом надо учитывать что часть цифр превращаются в буквы и они не должны быть перепутаны при декодировании.
    </string>

    <string name="theory_Moon_head">
        Шрифт Муна (англ. The Moon System of Embossed Reading) — шрифт для слепых, в котором используются упрощенные рельефные латинские буквы. Сторонники этой системы утверждают, что она проще в понимании, чем шрифт Брайля. Азбука Муна используется в основном людьми, потерявшими зрение в зрелом возрасте, и уже знающими форму букв.
        В отличие от состоящего из точек шрифта Брайля, шрифт Муна состоит из кривых, углов и линий. Полный алфавит содержит только девять символов в различной ориентации. В более продвинутых вариантах шрифта Муна знаки могут соответствовать как отдельным звукам, так и частям слов, целым словам и цифрам. На странице формата А4 помещается около семисот символов.
        Поскольку подготовка текста шрифтом Муна является достаточно трудоёмкой, в настоящее время он менее популярен, чем шрифт Брайля. Сейчас им пользуется около четырёхсот человек, большинство из которых проживает на территории Великобритании. Он также преподаётся в некоторых учебных заведениях Голландии и Германии.
        Литература, написанная шрифтом Муна, за пределами Англии практически недоступна.
    </string>
    <string name="theory_Moon_history">
        Шрифт Муна был разработан английским доктором Уильямом Муном (1818—1894), жившим в Брайтоне (Восточный Сассекс). После перенесенной в возрасте 21 года скарлатины он потерял зрение и, как многие люди, ослепшие во взрослом возрасте, считал шрифт Брайля неудобным.
        Мун впервые сформулировал идею создания новой письменности в 1843 году, а в 1845 им была опубликована первая принципиальная схема шрифта.
    </string>

    <string name="theory_Hill_head">
        Шифр Хилла — полиграммный шифр подстановки, основанный на линейной алгебре и модульной арифметике. Изобретён американским математиком Лестером Хиллом в 1929 году. Это был первый шифр, который позволил на практике (хотя и с трудом) одновременно оперировать более чем с тремя символами. Шифр Хилла не нашёл практического применения в криптографии из-за слабой устойчивости ко взлому и отсутствия описания алгоритмов генерации прямых и обратных матриц большого размера.
    </string>
    <string name="theory_Hill_history">
        Впервые шифр Хилла был описан в статье «Cryptography in an Algebraic Alphabet», опубликованной в журнале «The American Mathematical Monthly» в июне-июле 1929 года. В августе того же года Хилл расширил тему и выступил с речью о криптографии перед Американским математическим обществом в Боулдере, штат Колорадо. Позднее его лекция привела ко второй статье «Concerning Certain Linear Transformation Apparatus of Cryptography», которая была опубликована в журнале
        «The American Mathematical Monthly» в марте 1931 года. Дэвид Кан в своем труде «Взломщики кодов» так описал шифр Хилла и его место в истории криптографии:
        Хилл был одним из тех, кто разработал общий и мощный метод. К тому же шифр Хилла впервые перевел криптографию с использованием полиграмм в разряд практических дисциплин.
    </string>
    <string name="theory_Hill_cryptographic_strength">
        Стандартный шифр Хилла уязвим к атаке по выбранному открытому тексту, потому что в нём используются линейные операции. Криптоаналитик, который перехватит n^2 пар символ сообщения/символ шифротекста сможет составить систему линейных уравнений, которую обычно не сложно решить. Если окажется, что система не решаема, то необходимо всего лишь добавить ещё несколько пар символ сообщения/символ шифротекста. Такого рода расчеты средствами обычных алгоритмов линейной
        алгебры требует совсем немного времени. В связи с этим для увеличения криптостойкости в него должны быть добавлены какие-либо нелинейные операции. Комбинирование линейных операций, как в шифре Хилла, и нелинейных шагов привело к созданию подстановочно-перестановочной сети (например, сеть Фейстеля). Поэтому с определенной точки зрения можно считать современные блочные шифры как вид полиграммных шифров.
        Длина ключа — это двоичный логарифм от количества всех возможных ключей. Существует 26^{n^2} матриц размера n × n. Значит, log_2(26^{n^2}) или приблизительно 4.7n^2 — верхняя грань длины ключа для шифра Хилла, использующего матрицы n × n. Это только верхняя грань, поскольку не каждая матрица обратима, а только такие матрицы могут быть ключом. Количество обратимых матриц может быть рассчитано при помощи Китайской теоремы об остатках. Матрица обратима по модулю
        26 тогда и только тогда, когда она обратима и по модулю 2 и по модулю.
    </string>
    <string name="theory_Hill_mechanical_release">
        При работе с двумя символами за раз, шифр Хилла не предоставляет никаких конкретных преимуществ перед шифром Плэйфера, и даже уступает ему по криптостойкости и простоте вычислений на бумаге. По мере увеличения размерности ключа шифр быстро становится недоступным для расчетов на бумаге человеком. Шифр Хилла размерности 6 был реализован механически. Хилл с партнером получили патент на устройство (U.S. Patent 1 845 947), которое выполняло умножение матрицы 6 × 6 по
        модулю 26 при помощи системы шестеренок и цепей. Расположение шестеренок (а значит, и ключ) нельзя было изменять для конкретного устройства, поэтому в целях безопасности рекомендовалось тройное шифрование. Такая комбинация была очень сильной для 1929 года, и она показывает, что Хилл несомненно понимал концепции конфузии и диффузии. Однако устройство было довольно медленное, поэтому во Второй мировой войне машины Хилла были использованы только для шифрования трехсимвольного кода радиосигналов.
    </string>

    <string name="theory_Caesar_head">
        Шифр Цезаря, также известный как шифр сдвига, код Цезаря — один из самых простых и наиболее широко известных методов шифрования.
        Шифр Цезаря — это вид шифра подстановки, в котором каждый символ в открытом тексте заменяется символом, находящимся на некотором постоянном числе позиций левее или правее него в алфавите. Например, в шифре со сдвигом вправо на 3, А была бы заменена на Г, Б станет Д, и так далее.
        Шифр назван в честь римского полководца Гая Юлия Цезаря, использовавшего его для секретной переписки со своими генералами. Шаг шифрования, выполняемый шифром Цезаря, часто включается как часть более сложных схем, таких как шифр Виженера, и всё ещё имеет современное приложение в системе ROT13. Как и все моноалфавитные шифры, шифр Цезаря легко взламывается и не имеет почти никакого применения на практике.
    </string>

    <string name="theory_Playfair_head">
        Шифр Плейфера или квадрат Плейфера — ручная симметричная техника шифрования, в которой впервые использована замена биграмм. Изобретена в 1854 году английским физиком Чарльзом Уитстоном, но названа именем лорда Лайона Плейфера, который внёс большой вклад в продвижение использования данной системы шифрования в государственной службе. Шифр предусматривает шифрование пар символов (биграмм) вместо одиночных символов, как в шифре подстановки и в более сложных системах шифрования Виженера.
        Таким образом, шифр Плейфера более устойчив к взлому по сравнению с шифром простой замены, так как усложняется его частотный анализ. Он может быть проведён, но не для символов, а для биграмм. Так как возможных биграмм больше, чем символов, анализ значительно более трудоёмок и требует большего объёма зашифрованного текста.
    </string>
    <string name="theory_Playfair_history">
        Несмотря на то, что шифр был изобретением Уитстона, он стал известен как шифр Плейфера. Его первое описание было зарегистрировано в документе, подписанном Уитстоном 26 марта 1854 года. Друг Уитстона лорд Лайон Плейфер рекомендовал этот шифр для использования высшими государственными и военными деятелями. Однако Министерство иностранных дел Великобритании отклонило этот документ из-за сложности его восприятия. Когда Уитстон предложил продемонстрировать, что трое из четырёх мальчиков
        в соседней школе научатся использовать этот шифр за пятнадцать минут, заместитель министра иностранных дел ответил: «Это очень возможно, но вы никогда не научите этому атташе».
        Шифр использовался в тактических целях британскими вооружёнными силами во Второй Англо-Бурской войне и в Первой мировой войне, а также австралийцами и немцами во время Второй мировой войны. Причиной использования шифра Плейфера была его достаточная простота в применении и отсутствие необходимости в дополнительном специальном оборудовании. Основной целью использования этой системы шифрования была защита важной, но несекретной информации во время ведения боя. К тому времени, когда
        вражеские криптоаналитики взламывали сообщение, информация уже была бесполезна для них.
        Использование шифра Плейфера в настоящее время является нецелесообразным, поскольку современные компьютеры могут легко взломать шифр в течение нескольких секунд. Первый изданный алгоритм взлома шифра Плейфера был описан в 1914 году в брошюре объёмом 19 страниц Джозефом О. Моуборном.
    </string>
    <string name="theory_Playfair_description"><![CDATA[
        Шифр Плейфера использует матрицу 5х5 (для латинского алфавита, для кириллического алфавита необходимо увеличить размер матрицы до 4х8), содержащую ключевое слово или фразу. Для создания матрицы и использования шифра достаточно запомнить ключевое слово и четыре простых правила. Чтобы составить ключевую матрицу, в первую очередь нужно заполнить пустые ячейки матрицы буквами ключевого слова (не записывая повторяющиеся символы), потом заполнить оставшиеся ячейки матрицы символами алфавита,
        не встречающимися в ключевом слове, по порядку (в английских текстах обычно опускается символ «Q», чтобы уменьшить алфавит, в других версиях «I» и «J» объединяются в одну ячейку). Ключевое слово может быть записано в верхней строке матрицы слева направо, либо по спирали из левого верхнего угла к центру. Ключевое слово, дополненное алфавитом, составляет матрицу 5х5 и является ключом шифра.
        Для того чтобы зашифровать сообщение, необходимо разбить его на биграммы (группы из двух символов), например «Hello World» становится «HE LL OW OR LD», и отыскать эти биграммы в таблице. Два символа биграммы соответствуют углам прямоугольника в ключевой матрице. Определяем положения углов этого прямоугольника относительно друг друга. Затем, руководствуясь следующими 4 правилами, зашифровываем пары символов исходного текста:
      <ui>
          <li> Если два символа биграммы совпадают (или если остался один символ), добавляем после первого символа «Х», зашифровываем новую пару символов и продолжаем. В некоторых вариантах шифра Плейфера вместо «Х» используется «Q».</li>
          <li> Если символы биграммы исходного текста встречаются в одной строке, то эти символы замещаются на символы, расположенные в ближайших столбцах справа от соответствующих символов. Если символ является последним в строке, то он заменяется на первый символ этой же строки.</li>
          <li> Если символы биграммы исходного текста встречаются в одном столбце, то они преобразуются в символы того же столбца, находящиеся непосредственно под ними. Если символ является нижним в столбце, то он заменяется на первый символ этого же столбца.</li>
          <li> Если символы биграммы исходного текста находятся в разных столбцах и разных строках, то они заменяются на символы, находящиеся в тех же строках, но соответствующие другим углам прямоугольника.</li>
          <li> Для расшифровки необходимо использовать инверсию этих четырёх правил, откидывая символы «Х» (или «Q»), если они не несут смысла в исходном сообщении.</li>
      </ui>
   ]]> </string>
    <string name="theory_Playfair_cryptoanalysis">
        Как и большинство шифров формальной криптографии, шифр Плейфера также может быть легко взломан, если имеется достаточный объём текста. Получение ключа является относительно простым, если известны шифрованный и обычный текст. Когда известен только зашифрованный текст, можно провести частотный анализ, но не для 26 возможных символов латинского алфавита, а для 25 ⋅ 24 = 600 возможных биграмм (одна из букв и биграммы из двух одинаковых букв исключаются). Криптоаналитики анализируют соответствие
        между частотой появления биграмм в зашифрованном тексте и известной частотой появления биграмм в языке, на котором написано сообщение.
        Впервые алгоритм взлома шифра Плейфера был описан в брошюре лейтенанта Джозефа О. Моуборнома в 1914 году. Позднее, в 1939 году, криптоанализ шифра был приведен в книге Х. Ф. Гейнс "Cryptanalysis - a study of ciphers and their solution". Однако более подробное руководство для нахождения ключа для шифра Плейфера можно найти в главе 7 «Solution to polygrafic substitution systems» руководства Field Manual 34-40-2 Сухопутных Войск США.
        Шифр Плейфера подобен шифру двух квадратов, хотя относительная простота системы шифрования Плейфера упрощает идентификацию текста. Примечательно, что биграмма шифра Плейфера и её инверсия (AB и BA) будет расшифрована как другая биграмма и её инверсия (RE и ER). В английском языке есть много слов, содержащих такие инверсные биграммы, например REceivER и DEpartED. Идентификация близко лежащих инверсных биграмм зашифрованного текста и нахождение им соответствий в списке известных слов исходного
        текста является одним из легких способов построения исходного текста и начала конструирования ключа.
        Существует другой подход к криптоанализу шифра Плейфера, который называется Random-restart hill climbing. Он основывается на матрице случайных символов. С помощью простейших итераций матрица случайных символов максимально приближается к оригинальной матрице. Очевидно, что этот метод слишком сложен для человека, но компьютеры с помощью данного алгоритма могут взломать данный шифр, даже имея небольшой объём текста. Другой отличительной особенностью шифра Плейфера от шифра с двумя квадратами
        является то, что в нём никогда не встречаются биграммы с повторяющимися символами (например ЕЕ). Если в шифрованном тексте отсутствуют биграммы с повторяющимися символами и его длина достаточно велика, то можно предположить, что исходный текст зашифрован шифром Плейфера.
        Немецкая армия, ВВС и полиция использовали двойную систему шифрования Плейфера во Второй мировой войне как шифр «среднего сорта». Они добавили второй квадрат, так как во время Первой мировой войны шифр Плейфера был взломан. Из этого квадрата брали второй символ каждой биграммы, не используя ключевое слово и помещая символы в произвольном порядке. Но и этот шифр был взломан в Блечли-парк, потому что немцы использовали один и тот же шаблон сообщения. В восьми сообщениях, зашифрованных двойным
        шифром Плейфера, были использованы числа от одного до двенадцати, это и дало возможность достаточно легко взломать его.
        Позднее были предприняты попытки усовершенствовать шифр при помощи использования матрицы 7x4 и добавлением символов «*» и «#». Несмотря на то, что анализ шифра усложнился, его все равно можно взломать теми же методами, что и первоначальный.
    </string>

    <string name="theory_Shannon_Fano_head">
        Алгоритм Шеннона — Фано — один из первых алгоритмов сжатия, который впервые сформулировали американские учёные Клод Шеннон и Роберт Фано. Данный метод сжатия имеет большое сходство с алгоритмом Хаффмана, который появился на несколько лет позже и является логическим продолжением алгоритма Шеннона. Алгоритм использует коды переменной длины: часто встречающийся символ кодируется кодом меньшей длины, редко встречающийся — кодом большей длины. Коды Шеннона — Фано — префиксные, то есть никакое
        кодовое слово не является префиксом любого другого. Это свойство позволяет однозначно декодировать любую последовательность кодовых слов.
        Кодирование Шеннона — Фано (англ. Shannon–Fano coding) — алгоритм префиксного неоднородного кодирования. Относится к вероятностным методам сжатия (точнее, методам контекстного моделирования нулевого порядка). Подобно алгоритму Хаффмана, алгоритм Шеннона — Фано использует избыточность сообщения, заключённую в неоднородном распределении частот символов его (первичного) алфавита, то есть заменяет коды более частых символов короткими двоичными последовательностями, а коды более редких символов — более
        длинными двоичными последовательностями.
        Алгоритм был независимо друг от друга разработан Шенноном (публикация «Математическая теория связи», 1948 год) и, позже, Фано (опубликовано как технический отчёт).
    </string>
    <string name="theory_Shannon_Fano_calculation_algorithm">
        Код Шеннона — Фано строится с помощью дерева. Построение этого дерева начинается от корня. Всё множество кодируемых элементов соответствует корню дерева (вершине первого уровня). Оно разбивается на два подмножества с примерно одинаковыми суммарными вероятностями. Эти подмножества соответствуют двум вершинам второго уровня, которые соединяются с корнем. Далее каждое из этих подмножеств разбивается на два подмножества с примерно одинаковыми суммарными вероятностями. Им соответствуют вершины третьего уровня.
        Если подмножество содержит единственный элемент, то ему соответствует концевая вершина кодового дерева; такое подмножество разбиению не подлежит. Подобным образом поступаем до тех пор, пока не получим все концевые вершины. Ветви кодового дерева размечаем символами 1 и 0, как в случае кода Хаффмана.
        При построении кода Шеннона — Фано разбиение множества элементов может быть произведено, вообще говоря, несколькими способами. Выбор разбиения на уровне n может ухудшить варианты разбиения на следующем уровне (n + 1) и привести к неоптимальности кода в целом. Другими словами, оптимальное поведение на каждом шаге пути ещё не гарантирует оптимальности всей совокупности действий. Поэтому код Шеннона — Фано не является оптимальным в общем смысле, хотя и дает оптимальные результаты при некоторых распределениях вероятностей.
        Для одного и того же распределения вероятностей можно построить, вообще говоря, несколько кодов Шеннона — Фано, и все они могут дать различные результаты. Если построить все возможные коды Шеннона — Фано для данного распределения вероятностей, то среди них будут находиться и все коды Хаффмана, то есть оптимальные коды.
    </string>

    <string name="about_intro">Интро</string>
    <string name="about_hintIntro">Показать подсказки приложения</string>
    <string name="nextShowIntro">Для продолжения нажмите на подсказку</string>

    <string name="intro_theory_spinner">Выберите необходимый пункт в списке для уточнении информации о шифре</string>
    <string name="intro_crypto_enc_dec">Чтобы зашифровать или расшифровать текст выберите соответствующий пункт</string>
    <string name="intro_crypto_method">Для выбора метода шифрования или расшифрования текста выберите соответствующий пункт из списка</string>
    <string name="intro_crypto_clearForm">Очистка всех полей формы</string>
    <string name="intro_crypto_convert">Кнопка шифрования или дешифрования информации (в зависимости от выбранного пункта)</string>
    <string name="intro_crypto_copyBuf">Сохранение текста в буфер обмена</string>
    <string name="intro_crypto_share">Отправка данных на сторонний ресурс</string>
    <string name="intro_crypto_qrCode">Создание QR кода с возможностю сохранения во внутреннюю память или отправки третьему лицу</string>

    <string name="intro_qrCode_scan">Сканирования QR кода</string>
    <string name="intro_qrCode_create">Создание QR кода: вначале необходимо ввести текст</string>
    <string name="intro_qrCode_saveImage">Сохранения QR кода в галлерею</string>

    <string name="cipher_encVigener">Для шифрования необходимо записать ключ, повторяя его столько раз, чтобы длина ключа была равна длине исходного текста\n
                Формула: Y=(X+K)mod L, где где X - номер буквы в алфавите, K - номер буквы ключа в алфавите, L - объем алфавита</string>
    <string name="cipher_decVigener">Для расшифрования необходимо записать ключ, повторяя его столько раз, чтобы длина ключа была равна длине исходного текста\n
                Формула: Y=(X-K)mod L, где где X - номер буквы в алфавите, K - номер буквы ключа в алфавите, L - объем алфавита</string>
    <string name="cipher_encCaesar">Формула шифрования: Y=(X+K)mod L, где X - номер буквы в алфавите, K - ключ, L - объем алфавита</string>
    <string name="cipher_decCaesar">Формула расшифровки: Y=(X-K)mod L, где X - номер буквы в алфавите, K - ключ, L - объем алфавита</string>
    <string name="cipher_atbash">Формула для зашифровки и расшифровки: Y=M-N+1, где M = объем алфавита, N - номер буквы в алфавите</string>

</resources>